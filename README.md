# 컴퓨터 알고리즘 그룹A 팀과제
*김진하 이훈 양수진*  


1. **허프만 코드에 대한 설명**
* 1951년 데이비트 허프만이 25살 때 고안한 데이터를 효율적으로 압축하는 데에 쓰이는 방법으로, 기호들의 빈도를 활용하여 정보를 압축하는 **무손실** 압축 시스템이자 *탐욕 알고리즘(Greedy Algorithm)* 중 하나이다.  

* 등장 빈도가 높은 문자는 짧은 비트로, 등장 빈도가 낮은 문자는 긴 비트로 표현한다. (이를 *가변 길이 코드*라고 함) 이러한 과정을 거침으로써 표현하는 데에 많은 수의 비트가 필요한 데이터를 더 적은 수의 비트로 표현할 수 있게 만든다.
---
2. **허프만 코드의 장단점**
* 장점  
 허프만 코드의 장점은 가변 길이의 이진 코드를 사용함으로써 **더 많은 공간을 절약**할 수 있고, 문자열에서 등장 빈도수가 많은 기호, 문자를 더 짧게 표현하여 많은 양의 데이터를 **더 간단하게 표현**할 수 있다.  
그리고 무손실 압축 시스템이기 때문에 표현하고자 하는 데이터의 모든 정보를 전달할 수 있다는 장점이 있다.

* 단점  
 허프만 코드의 단점은 무손실 압축 시스템에서 비롯되는데, 무손실이라는 점에서 데이터의 모든 값을 표현하기 위해 빈도수가 적은 데이터 역시 긴 비트로 표현하게 되면서 **손실 압축 시스템보다 압축률이 비교적 낮다.**  
또 다른 단점으로는 **인코딩이 비교적 느린 과정을 거친다**는 것이다. 통계적 모델, 또 다른 인코딩을 위한 2개의 패스를 사용하는데, 이 때문에 허프만 코드를 사용하는 무손실 압축 기술은 다른 기술보다 상당히 느린 속도를 갖게 된다.  
마지막으로 모든 이진 코드의 길이가 다르기 때문에, 디코딩 프로그램이 **인코딩된 데이터가 손상되었는지 알기 힘들다**. 이러한 점은 잘못된 디코딩과 잘못된 결과를 도출할 수도 있다.
---
3. **시간복잡도 계산법**
* 기본적으로 허프만 코드를 이용하기 전의 데이터와 허프만 코드를 사용한 후의 인코딩된 데이터의 크기를 보면 데이터의 압축률을 알아볼 수 있고, 디코딩을 한 데이터의 크기와 원본 데이터와 크기를 비교하면 데이터 손실의 유무를 알 수 있다.  

* 시간복잡도를 보자면, 이진 트리를 만들어서 허프만 코드를 작성할 때  
	* 입력되는 문자의 수 n에 맞추어 n개의 노드를 생성하고 빈도수를 노드에 저장 : ***O(n)***  
	* 우선순위 큐를 만드는 데에, 힙(heap) 자료구조를 사용하여 생성: ***O(n)***  
	* 최소 빈도수를 가진 노드 2개를 큐에서 제거하고 새 노드를 큐에 삽입하는 연산을 수행: ***O(logn)***  
	* 큐에서 최소 빈도수 노드 2개를 삭제하고 1개의 새 노드를 추가하기 때문에 큐에서의 최종적인 시간복잡도: ***O(nlogn)***  
	* 마지막 트리의 리턴: ***O(1)***  

* 따라서 최종 시간복잡도는 ***O(n) + O(n) + O(nlogn) + O(1)***
---
4. **코드 설명**
>self.___... 를 이용하여 노드와 필요한 변수를 정의  

>엣지노드가 아닐 때 까지 재귀
```
 if(node.left):
        output(node.left, Value)
    if(node.right):
        output(node.right, Value)
```

>엣지 노드에 도착하면 허프만 코드를 출력.
```
if(not node.left and not node.right):
    print(node.symbol, {Value})
```

>영어문장 입력, 소문자로 변경 후 아스키 코드를 이용해 빈도수 카운트  

>빈도수가 적은 순서대로 정렬
```
while (len(nodes) > 1):
    nodes = sorted(nodes, key=lambda x: x.freq)
```

>빈도수가 작은 노드 2개를 합쳐 제거 후 새로운 노드를 추가
```
left = nodes[0]
right = nodes[1]

left.huff = 0
right.huff = 1

newNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right)

nodes.remove(left)
nodes.remove(right)
nodes.append(newNode)
```

>출력
```
output(nodes[0])
```

---
5. **코드의 시간복잡도 계산**
* 입력되는 문자 수 n개의 노드생성과 빈도수저장: *O(n)*
* 힙 생성: *O(n)*
* 빈도수 작은 순서로 정렬: *O(n)*
* 노드 삭제와 새 노드 추가하는 연산: *O(nlogn)*
* 마지막 트리의 리턴: *O(1)*  

>위 허프만코드의 시간복잡도 = **O(3n+nlogn+1)**
